#pragma once

#include"2ipslnfa_nfa.h"

// A class represents a state, and the result of entering a letter to it.
class StatesSet {
public:
	int after0;
	int after1;
	bool* states;
	// kind shows a specified kind of states set.
	// REMEMBER:code of kinds start from 0.
	StatesSet() {
		after0 = -1;
		after1 = -1;
		states = nullptr;
	}
};
// Transfer an NFA to a DFA.
int** NTD(int** graph, int& states, int*& receive, int& finalSize) {
	// REMEMBER: states starts counting from 1.
	// when a states' states set is calculated, record it with two boolean arrays.
	bool* after0 = new bool[states];
	bool* after1 = new bool[states];
	// an int variable, records how many kinds of states set there are now.
	int counter{ 0 };
	// an int variable, records how many recorded StatesSet,
	// including results generated by entering 0 and 1 there are now.
	int numbers{ 0 };
	// kinds states counting from 0.
	const int MAX = static_cast<int>(pow(2, states));
	StatesSet* sets = new StatesSet[MAX];
	for (int i{ 0 }; i < MAX; i++) {
		sets[i].states = new bool[states];
		for (int j{ 0 }; j < states; j++)
			sets[i].states[j] = false;
	}
	// A queue of states sets wating to produce their results
	// of entering a letter.
	queue<StatesSet> waiting;

	// use kinds[0] to show q0.
	sets[counter].states[0] = true;
	waiting.push(sets[counter]);
	counter++;
	// entering 0,entering 1; a single time of circulation 
	// consists of these two paragraph of assignment.
	// REMINDER: when a new kind of sets appears,counter++,

	while (!waiting.empty()) {
		// reset the temporary states sets.
		for (int i{ 0 }; i < states; i++) {
			after0[i] = false;
			after1[i] = false;
		}
		StatesSet now = waiting.front();
		waiting.pop();
		for (int n{ 0 }; n < states; n++) {
			if (now.states[n] == true)
				for (int i{ 0 }; i < states; i++) {
					if (graph[n][i] == 2 || graph[n][i] == 0)
						after0[i] = true;
					if (graph[n][i] == 2 || graph[n][i] == 1)
						after1[i] = true;
				}
		}
		int nowhere{ 0 };
		for (int i{ 0 }; i < states; i++)
			if (after0[i] == false)
				nowhere++;
		if (nowhere == states)
			sets[numbers].after0 = -1;
		else {
			// Jugde whether after0 is repeated, with no 'numbers++'.
			for (int i{ 0 }; i < counter; i++) {
				// Innitialize the same variable.
				int same{ 0 };
				for (int j{ 0 }; j < states; j++) {
					if (sets[i].states[j] == after0[j])
						same++;
				}
				// a new kind of states set.
				if (i == counter - 1)
					if (same < states) {
						sets[numbers].after0 = counter;
						for (int k{ 0 }; k < states; k++)
							sets[counter].states[k] = after0[k];
						waiting.push(sets[counter]);
						counter++;
						break;
					}
				// an old kind of states set.
				if (same == states) {
					sets[numbers].after0 = i;
					break;
				}
			}
		}
		nowhere = 0;
		for (int i{ 0 }; i < states; i++)
			if (after1[i] == false)
				nowhere++;
		if (nowhere == states) {
			sets[numbers].after1 = -1;
			numbers++;
		}
		else {
			// Jugde whether after1 is repeated, with 'numbers++',
			// to guarantee that 'numbers' only increases once.
			for (int i{ 0 }; i < counter; i++) {
				int same{ 0 };
				for (int j{ 0 }; j < states; j++)
					if (sets[i].states[j] == after1[j]) {
						same++;
					}
				// a new kind of states set.
				if (i == counter - 1)
					if (same < states) {
						sets[numbers].after1 = counter;
						for (int k{ 0 }; k < states; k++)
							sets[counter].states[k] = after1[k];
						waiting.push(sets[counter]);
						counter++;
						numbers++;
						break;
					}
				// an old kind of states set.
				if (same == states) {
					sets[numbers].after1 = i;
					numbers++;
					break;
				}
			}
		}
	}

	// Now the states sets have all been determined.
	int** result = new int* [counter];
	for (int i{ 0 }; i < counter; i++) {
		result[i] = new int[counter];
		for (int j{ 0 }; j < counter; j++)
			result[i][j] = -1;
	}
	for (int i{ 0 }; i < counter; i++) {
		if (sets[i].after0 == sets[i].after1) {
			if (sets[i].after0 != -1) {
				result[i][sets[i].after0] = 2;
			}
		}
		else {
			if (sets[i].after0 != -1) {
				result[i][sets[i].after0] = 0;
			}
			if (sets[i].after1 != -1) {
				result[i][sets[i].after1] = 1;
			}
		}
	}
	// mark the final states.
	queue<int> temp;
	int n = finalSize;
	for (int i{ 0 }; i < counter; i++) {
		for (int j{ 0 }; j < finalSize; j++) {
			int x = receive[j];
			if (sets[i].states[x] == true) {
				temp.push(i);
				break;
			}
		}
	}
	
	
	cout << endl;
	//finalStates = nullptr;
	delete[] receive;
	receive = nullptr;
	receive = new int[static_cast<int>(temp.size())];
	finalSize = static_cast<int>(temp.size());
	for (int i{ 0 }; i < finalSize; i++) {
		receive[i] = temp.front();
		temp.pop();
	}
	
	// release the memory.
	delete[] after0;
	delete[] after1;
	after0 = nullptr;
	after1 = nullptr;
	for (int i{ 0 }; i < MAX; i++) {
		delete[] sets[i].states;
		sets[i].states = nullptr;
	}
	// renew the value of states.
	states = counter;
	




	//cout << "\t";
	//for (int i = 0; i < counter; i++) {
	//	if (i < 10) { cout << i << "   "; }
	//	else if (i >= 10) { cout << i << "   "; }
	//}
	//cout << endl;
	//for (int i = 0; i < counter; i++) {
	//	cout << i << "\t";
	//	for (int j = 0; j < counter; j++) {
	//		cout << result[i][j] << "  ";
	//	}
	//	cout << endl;
	//}



	// Delete sets.
	delete[] sets;
	sets = nullptr;
	// return the result. 
	return result;
}